#!/usr/bin/python3
import argparse
import sys
import os
import time
import json
import requests
from collections import defaultdict
try:
    import curses
except ImportError:
    curses = None
try:
    import pyperclip
except ImportError:
    pyperclip = None

# Default settings
default_settings = {
    'text_color': 'green',
    'animation_enabled': True
}

# Cyberdeck directory in user's home
CYBERDECK_DIR = os.path.join(os.path.expanduser("~"), ".cyberdeck")
SETTINGS_FILE = os.path.join(CYBERDECK_DIR, "settings.json")
COMMANDS_FILE = os.path.join(CYBERDECK_DIR, "commands.json")
ERROR_LOG = os.path.join(CYBERDECK_DIR, "error.log")

def log_error(message):
    """Log errors to ~/.cyberdeck/error.log."""
    try:
        os.makedirs(CYBERDECK_DIR, exist_ok=True)
        with open(ERROR_LOG, 'a') as f:
            timestamp = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
            f.write(f"[{timestamp}] {message}\n")
    except Exception:
        pass

def load_settings():
    """Load settings from ~/.cyberdeck/settings.json or return defaults."""
    try:
        os.makedirs(CYBERDECK_DIR, exist_ok=True)
        with open(SETTINGS_FILE, 'r') as f:
            return json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        return default_settings.copy()

def save_settings(settings):
    """Save settings to ~/.cyberdeck/settings.json."""
    try:
        os.makedirs(CYBERDECK_DIR, exist_ok=True)
        with open(SETTINGS_FILE, 'w') as f:
            json.dump(settings, f, indent=4)
    except Exception as e:
        log_error(f"Failed to save settings: {str(e)}")

# Global settings
settings = load_settings()

def version_tuple(v):
    """Convert version string to tuple for comparison."""
    return tuple(map(int, v.split('.')))

def update_commands():
    """Fetch and update commands.json if remote version is higher."""
    url = "https://raw.githubusercontent.com/DotNetRussell/CyberDeck/refs/heads/main/commands.json"
    local_file = COMMANDS_FILE
    try:
        response = requests.get(url, timeout=5)
        response.raise_for_status()
        remote_data = response.json()
        remote_version = remote_data.get("Version", "0.0.0.0")
        local_version = "0.0.0.0"
        if os.path.exists(local_file):
            with open(local_file, 'r') as f:
                local_data = json.load(f)
                local_version = local_data.get("Version", "0.0.0.0")
        if version_tuple(remote_version) > version_tuple(local_version):
            with open(local_file, 'w') as f:
                json.dump(remote_data, f, indent=4)
    except Exception as e:
        log_error(f"Failed to update commands.json: {str(e)}")

def convert_line_endings(input_file, output_file, format_type):
    """Convert line endings of a file to the specified format."""
    try:
        if not os.path.isabs(input_file):
            cyberdeck_input = os.path.join(CYBERDECK_DIR, input_file)
            if os.path.exists(cyberdeck_input):
                input_file = cyberdeck_input
        if not os.path.exists(input_file):
            raise FileNotFoundError(f"Input file '{input_file}' not found.")
        
        with open(input_file, 'r', newline='') as infile:
            content = infile.read()
        
        if format_type.lower() == 'unix':
            new_line_ending = '\n'
        elif format_type.lower() == 'windows':
            new_line_ending = '\r\n'
        elif format_type.lower() == 'mac':
            new_line_ending = '\r'
        else:
            raise ValueError(f"UNSUPPORTED FORMAT: {format_type}. USE 'UNIX', 'WINDOWS', OR 'MAC'.")

        lines = content.replace('\r\n', '\n').replace('\r', '\n').split('\n')
        
        if not os.path.isabs(output_file):
            output_file = os.path.join(CYBERDECK_DIR, output_file)
        os.makedirs(os.path.dirname(output_file) or '.', exist_ok=True)
        
        with open(output_file, 'w', newline=new_line_ending) as outfile:
            outfile.write(new_line_ending.join(lines))
        
        return f"SUCCESSFULLY CONVERTED {input_file} TO {format_type.upper()} LINE ENDINGS AND SAVED TO {output_file}"
    
    except FileNotFoundError as e:
        return f"ERROR: {str(e).upper()}"
    except PermissionError:
        return f"ERROR: PERMISSION DENIED WHEN ACCESSING FILES."
    except Exception as e:
        return f"ERROR: {str(e).upper()}"

def type_text(stdscr, y, text, color_pair, delay=0.01, x_offset=None, center_vertically=False):
    """Display text with wrapping, safe character handling, centered horizontally and optionally vertically."""
    safe_text = ''.join(c if 32 <= ord(c) <= 126 else '' for c in text)
    max_y, max_x = stdscr.getmaxyx()
    max_width = max_x - 4
    
    lines = []
    current_line = ""
    for word in safe_text.split():
        if len(current_line) + len(word) + 1 <= max_width:
            current_line += (word + " ") if current_line else word
        else:
            if current_line:
                lines.append(current_line.rstrip())
            current_line = word + " "
    if current_line:
        lines.append(current_line.rstrip())
    
    if center_vertically:
        total_lines = len(lines)
        y = (max_y - total_lines) // 2
        if y < 0:
            y = 0
    
    current_y = y
    for line in lines:
        if current_y >= max_y:
            log_error(f"Text wrapping exceeded terminal height at y={current_y}: {line}")
            break
        x = x_offset if x_offset is not None else (max_x - len(line)) // 2
        if x < 0:
            x = 0
        if not settings['animation_enabled']:
            try:
                stdscr.addstr(current_y, x, line, color_pair)
            except Exception as e:
                log_error(f"Failed to display text (non-animated) at y={current_y}, x={x}: {str(e)}")
            current_y += 1
            continue
        
        try:
            for char in line:
                if current_y >= max_y:
                    log_error(f"Text wrapping exceeded terminal height at y={current_y}, x={x}: {line}")
                    break
                stdscr.addch(current_y, x, char, color_pair)
                stdscr.refresh()
                x += 1
                time.sleep(delay)
            current_y += 1
        except Exception as e:
            try:
                stdscr.addstr(current_y, x_offset if x_offset is not None else (max_x - len(line)) // 2, line, color_pair)
                current_y += 1
            except Exception as e2:
                log_error(f"Failed to display text at y={current_y}, x={x_offset if x_offset is not None else (max_x - len(line)) // 2}: {str(e)} / {str(e2)}")
                current_y += 1
    
    return current_y

def boot_sequence(stdscr):
    """Display a Nostromo-inspired boot sequence with vertical centering."""
    stdscr.clear()
    max_y, _ = stdscr.getmaxyx()
    lines = [
        "WEYLAND-YUTANI CORP SYSTEM INITIALIZATION",
        "MEMORY CHECK: 16MB OK",
        "CPU: 8086 PROCESSOR DETECTED",
        "STORAGE: 512KB AVAILABLE",
        "INTERFACE: CRT TERMINAL v1.0",
        "BOOTING MU/TH/UR OS v2.1.7",
        "INITIALIZATION COMPLETE"
    ]
    color_pair = get_color_pair()
    start_y = (max_y - len(lines) - 1) // 2
    if start_y < 0:
        start_y = 0
    current_y = start_y
    for line in lines:
        if current_y >= max_y - 1:
            log_error(f"Boot sequence exceeded terminal height at y={current_y}: {line}")
            break
        current_y = type_text(stdscr, current_y, line, color_pair | curses.A_BOLD)
    type_text(stdscr, max_y - 1, "PRESS ANY KEY TO CONTINUE", color_pair)
    stdscr.refresh()
    stdscr.getch()

def shutdown_sequence(stdscr):
    """Display a hacker-inspired shutdown animation with vertical centering."""
    stdscr.clear()
    max_y, _ = stdscr.getmaxyx()
    lines = [
        "SYSTEM TERMINATION INITIATED",
        "DEACTIVATING CORE MODULES...",
        "1010101010101010101010101010",
        "FLUSHING MEMORY BUFFERS...",
        "0101010101010101010101010101",
        "DISCONNECTING NETWORK LINKS",
        "WEYLAND-YUTANI CORP: OFFLINE",
        "SHUTDOWN COMPLETE"
    ]
    color_pair = get_color_pair()
    start_y = (max_y - len(lines) - 1) // 2
    if start_y < 0:
        start_y = 0
    current_y = start_y
    for line in lines:
        if current_y >= max_y - 1:
            log_error(f"Shutdown sequence exceeded terminal height at y={current_y}: {line}")
            break
        current_y = type_text(stdscr, current_y, line, color_pair | curses.A_BOLD)
        time.sleep(0.2)
    type_text(stdscr, max_y - 1, "SHUTDOWN COMPLETE", color_pair)
    stdscr.refresh()
    time.sleep(1)

def get_color_pair():
    """Return the color pair based on settings."""
    color_map = {
        'green': curses.color_pair(1),
        'white': curses.color_pair(2),
        'cyan': curses.color_pair(3),
        'red': curses.color_pair(4),
        'yellow': curses.color_pair(5),
        'purple': curses.color_pair(6) | curses.A_BOLD,
        'pink': curses.color_pair(6),
        'toxic green': curses.color_pair(1) | curses.A_BOLD
    }
    return color_map.get(settings['text_color'], curses.color_pair(1))

def list_menu(stdscr, title, items, get_text, is_first=True):
    """General navigable list menu with scrolling support."""
    current_row = 0
    max_row = len(items) - 1
    first_draw = is_first
    max_y, max_x = stdscr.getmaxyx()
    scroll_offset = 0
    
    max_item_width = max(len(get_text(item)) for item in items) + 2
    x_offset = (max_x - max_item_width) // 2
    if x_offset < 0:
        x_offset = 0
    padded_items = [get_text(item).ljust(max_item_width - 2) for item in items]
    
    # Calculate max visible items (reserve lines for header, title, instruction)
    max_visible_items = max_y - 4  # Header, title, spacing, instruction
    if max_visible_items < 1:
        max_visible_items = 1
    
    while True:
        stdscr.clear()
        color_pair = get_color_pair()
        
        # Adjust scroll_offset to keep current_row visible
        if current_row < scroll_offset:
            scroll_offset = current_row
        elif current_row >= scroll_offset + max_visible_items:
            scroll_offset = current_row - max_visible_items + 1
        
        # Calculate visible items
        visible_items = padded_items[scroll_offset:scroll_offset + max_visible_items]
        
        # Calculate total lines for vertical centering
        total_lines = len(visible_items) + 4
        start_y = (max_y - total_lines) // 2
        if start_y < 0:
            start_y = 0
        
        current_y = start_y
        if first_draw:
            current_y = type_text(stdscr, current_y, "=== MU/TH/UR INTERFACE ===", color_pair | curses.A_BOLD)
            current_y = type_text(stdscr, current_y, f"== {title.upper()} ==", color_pair)
            current_y += 1
            for idx, item in enumerate(visible_items):
                global_idx = idx + scroll_offset
                if current_y >= max_y - 1:
                    log_error(f"Menu item exceeded terminal height at y={current_y}: {item}")
                    break
                text = f"█ {item}" if global_idx == current_row else f"  {item}"
                current_y = type_text(stdscr, current_y, text, color_pair | (curses.A_REVERSE if global_idx == current_row else 0), x_offset=x_offset)
            type_text(stdscr, max_y - 1, "USE ARROW KEYS TO NAVIGATE, ENTER TO SELECT, ESC TO BACK", color_pair)
            first_draw = False
        else:
            stdscr.addstr(current_y, (max_x - len("=== MU/TH/UR INTERFACE ===")) // 2, "=== MU/TH/UR INTERFACE ===", color_pair | curses.A_BOLD)
            current_y += 1
            stdscr.addstr(current_y, (max_x - len(f"== {title.upper()} ==")) // 2, f"== {title.upper()} ==", color_pair)
            current_y += 1
            for idx, item in enumerate(visible_items):
                global_idx = idx + scroll_offset
                if current_y >= max_y - 1:
                    log_error(f"Menu item exceeded terminal height at y={current_y}: {item}")
                    break
                stdscr.addstr(current_y, x_offset, f"█ {item}" if global_idx == current_row else f"  {item}", 
                             color_pair | (curses.A_REVERSE if global_idx == current_row else 0))
                current_y += 1
            stdscr.addstr(max_y - 1, (max_x - len("USE ARROW KEYS TO NAVIGATE, ENTER TO SELECT, ESC TO BACK")) // 2, 
                         "USE ARROW KEYS TO NAVIGATE, ENTER TO SELECT, ESC TO BACK", color_pair)
        stdscr.refresh()
        key = stdscr.getch()
        if key == curses.KEY_UP and current_row > 0:
            current_row -= 1
        elif key == curses.KEY_DOWN and current_row < max_row:
            current_row += 1
        elif key == 10:
            return items[current_row], first_draw
        elif key == 27:
            return None, first_draw

def show_details(stdscr, cmd):
    """Show command details screen with copy to clipboard option."""
    color_pair = get_color_pair()
    max_y, max_x = stdscr.getmaxyx()
    lines = [
        "=== MU/TH/UR INTERFACE ===",
        f"NAME: {cmd['Name']}",
        "",
        f"DESCRIPTION: {cmd['Description']}",
        "",
        f"COMMAND: {cmd['Command']}"
    ]
    start_y = (max_y - len(lines) - 1) // 2
    if start_y < 0:
        start_y = 0
    while True:
        stdscr.clear()
        current_y = start_y
        for line in lines:
            if current_y >= max_y - 1:
                log_error(f"Details screen exceeded terminal height at y={current_y}: {line}")
                break
            current_y = type_text(stdscr, current_y, line, color_pair | (curses.A_BOLD if line.startswith("===") else 0))
        type_text(stdscr, max_y - 1, "PRESS C TO COPY, ANY OTHER KEY TO RETURN.", color_pair)
        stdscr.refresh()
        key = stdscr.getch()
        if key == ord('c') or key == ord('C'):
            if pyperclip:
                try:
                    pyperclip.copy(cmd['Command'])
                    stdscr.clear()
                    current_y = start_y
                    current_y = type_text(stdscr, current_y, "=== MU/TH/UR INTERFACE ===", color_pair | curses.A_BOLD)
                    current_y = type_text(stdscr, current_y, "COMMAND COPIED TO CLIPBOARD.", color_pair)
                    type_text(stdscr, max_y - 1, "PRESS ANY KEY TO RETURN.", color_pair)
                    stdscr.refresh()
                    stdscr.getch()
                except Exception as e:
                    stdscr.clear()
                    current_y = start_y
                    current_y = type_text(stdscr, current_y, "=== MU/TH/UR INTERFACE ===", color_pair | curses.A_BOLD)
                    current_y = type_text(stdscr, current_y, f"ERROR: FAILED TO COPY: {str(e).upper()}", color_pair)
                    type_text(stdscr, max_y - 1, "PRESS ANY KEY TO RETURN.", color_pair)
                    stdscr.refresh()
                    stdscr.getch()
            else:
                stdscr.clear()
                current_y = start_y
                current_y = type_text(stdscr, current_y, "=== MU/TH/UR INTERFACE ===", color_pair | curses.A_BOLD)
                current_y = type_text(stdscr, current_y, "ERROR: PYPERCLIP NOT INSTALLED.", color_pair)
                type_text(stdscr, max_y - 1, "PRESS ANY KEY TO RETURN.", color_pair)
                stdscr.refresh()
                stdscr.getch()
        else:
            break

def run_commands(stdscr):
    """Handle the Commands menu with categories and commands."""
    color_pair = get_color_pair()
    max_y, max_x = stdscr.getmaxyx()
    if not os.path.exists(COMMANDS_FILE):
        stdscr.clear()
        lines = [
            "=== MU/TH/UR INTERFACE ===",
            "NO COMMANDS AVAILABLE. PRESS ANY KEY TO RETURN."
        ]
        start_y = (max_y - len(lines) - 1) // 2
        if start_y < 0:
            start_y = 0
        current_y = start_y
        current_y = type_text(stdscr, current_y, lines[0], color_pair | curses.A_BOLD)
        current_y = type_text(stdscr, current_y, lines[1], color_pair)
        type_text(stdscr, max_y - 1, "PRESS ANY KEY TO RETURN.", color_pair)
        stdscr.refresh()
        stdscr.getch()
        return

    with open(COMMANDS_FILE, 'r') as f:
        data = json.load(f)

    categories = {cat['id']: cat['Name'] for cat in data['Categories']}
    commands = data['commands']
    groups = defaultdict(list)
    for cmd in commands:
        groups[cmd['Category']].append(cmd)

    category_ids = sorted(groups.keys())
    first_draw = True

    while True:
        selected_cat, first_draw = list_menu(stdscr, "COMMANDS CATEGORIES", category_ids, lambda cid: categories[cid], is_first=first_draw)
        if selected_cat is None:
            return
        category_commands = sorted(groups[selected_cat], key=lambda c: c['Name'])
        selected_cmd, _ = list_menu(
            stdscr,
            categories[selected_cat],
            category_commands,
            lambda cmd: f"{cmd['Name']}: {cmd['Description']}",
            is_first=False
        )
        if selected_cmd is None:
            first_draw = False
            continue
        show_details(stdscr, selected_cmd)
        first_draw = False

def run_search(stdscr):
    """Handle the Search menu with query and results."""
    color_pair = get_color_pair()
    max_y, max_x = stdscr.getmaxyx()
    stdscr.clear()
    prompt = "ENTER SEARCH QUERY: "
    lines = ["=== MU/TH/UR INTERFACE ===", prompt + "__________"]
    start_y = (max_y - len(lines) - 1) // 2
    if start_y < 0:
        start_y = 0
    current_y = start_y
    current_y = type_text(stdscr, current_y, lines[0], color_pair | curses.A_BOLD)
    type_text(stdscr, max_y - 1, prompt + "__________", color_pair)
    stdscr.move(max_y - 1, (max_x - len(prompt + "__________")) // 2 + len(prompt))
    stdscr.refresh()
    curses.echo()
    try:
        query = stdscr.getstr().decode('utf-8').strip().lower()
    except Exception as e:
        log_error(f"Failed to get search query: {str(e)}")
        query = ""
    curses.noecho()
    if not query:
        stdscr.clear()
        lines = [
            "=== MU/TH/UR INTERFACE ===",
            "NO QUERY ENTERED. PRESS ANY KEY TO RETURN."
        ]
        start_y = (max_y - len(lines) - 1) // 2
        if start_y < 0:
            start_y = 0
        current_y = start_y
        current_y = type_text(stdscr, current_y, lines[0], color_pair | curses.A_BOLD)
        current_y = type_text(stdscr, current_y, lines[1], color_pair)
        type_text(stdscr, max_y - 1, "PRESS ANY KEY TO RETURN.", color_pair)
        stdscr.refresh()
        stdscr.getch()
        return

    if not os.path.exists(COMMANDS_FILE):
        stdscr.clear()
        lines = [
            "=== MU/TH/UR INTERFACE ===",
            "NO COMMANDS AVAILABLE FOR SEARCH. PRESS ANY KEY TO RETURN."
        ]
        start_y = (max_y - len(lines) - 1) // 2
        if start_y < 0:
            start_y = 0
        current_y = start_y
        current_y = type_text(stdscr, current_y, lines[0], color_pair | curses.A_BOLD)
        current_y = type_text(stdscr, current_y, lines[1], color_pair)
        type_text(stdscr, max_y - 1, "PRESS ANY KEY TO RETURN.", color_pair)
        stdscr.refresh()
        stdscr.getch()
        return

    with open(COMMANDS_FILE, 'r') as f:
        data = json.load(f)

    commands = data['commands']
    filtered = [cmd for cmd in commands if query in cmd['Name'].lower() or query in cmd['Description'].lower()]
    if not filtered:
        stdscr.clear()
        lines = [
            "=== MU/TH/UR INTERFACE ===",
            "NO RESULTS FOUND. PRESS ANY KEY TO RETURN."
        ]
        start_y = (max_y - len(lines) - 1) // 2
        if start_y < 0:
            start_y = 0
        current_y = start_y
        current_y = type_text(stdscr, current_y, lines[0], color_pair | curses.A_BOLD)
        current_y = type_text(stdscr, current_y, lines[1], color_pair)
        type_text(stdscr, max_y - 1, "PRESS ANY KEY TO RETURN.", color_pair)
        stdscr.refresh()
        stdscr.getch()
        return

    sorted_filtered = sorted(filtered, key=lambda c: c['Name'])
    selected_cmd, _ = list_menu(
        stdscr,
        "SEARCH RESULTS",
        sorted_filtered,
        lambda cmd: f"{cmd['Name']}: {cmd['Description']}",
        is_first=True
    )
    if selected_cmd is not None:
        show_details(stdscr, selected_cmd)

def run_settings(stdscr, color_pair):
    """Handle the Settings menu with scrolling support."""
    global settings
    max_y, max_x = stdscr.getmaxyx()
    color_options = ["GREEN", "WHITE", "CYAN", "RED", "YELLOW", "PURPLE", "PINK", "TOXIC GREEN"]
    animation_options = ["ENABLED", "DISABLED"]
    current_color_row = color_options.index(settings['text_color'].upper())
    current_anim_row = 0 if settings['animation_enabled'] else 1
    selected_section = 0
    max_color_row = len(color_options) - 1
    max_anim_row = len(animation_options) - 1
    first_draw = True
    color_scroll_offset = 0
    anim_scroll_offset = 0

    max_item_width = max(len(option) for option in color_options + animation_options) + 2
    x_offset = (max_x - max_item_width) // 2
    if x_offset < 0:
        x_offset = 0
    padded_color_options = [option.ljust(max_item_width - 2) for option in color_options]
    padded_animation_options = [option.ljust(max_item_width - 2) for option in animation_options]

    # Calculate max visible items per section (split available space)
    max_visible_items = (max_y - 6) // 2  # Header, title, color label, animation label, instruction, spacing
    if max_visible_items < 1:
        max_visible_items = 1

    while True:
        stdscr.clear()
        # Adjust scroll offsets
        if selected_section == 0:
            if current_color_row < color_scroll_offset:
                color_scroll_offset = current_color_row
            elif current_color_row >= color_scroll_offset + max_visible_items:
                color_scroll_offset = current_color_row - max_visible_items + 1
        else:
            if current_anim_row < anim_scroll_offset:
                anim_scroll_offset = current_anim_row
            elif current_anim_row >= anim_scroll_offset + max_visible_items:
                anim_scroll_offset = current_anim_row - max_visible_items + 1

        visible_color_items = padded_color_options[color_scroll_offset:color_scroll_offset + max_visible_items]
        visible_anim_items = padded_animation_options[anim_scroll_offset:anim_scroll_offset + max_visible_items]

        total_lines = len(visible_color_items) + len(visible_anim_items) + 5
        start_y = (max_y - total_lines) // 2
        if start_y < 0:
            start_y = 0

        if first_draw:
            current_y = start_y
            current_y = type_text(stdscr, current_y, "=== MU/TH/UR INTERFACE ===", color_pair | curses.A_BOLD)
            current_y = type_text(stdscr, current_y, "== SETTINGS ==", color_pair)
            current_y += 1
            current_y = type_text(stdscr, current_y, "TEXT COLOR:", color_pair)
            for idx, option in enumerate(visible_color_items):
                global_idx = idx + color_scroll_offset
                if current_y >= max_y - 1:
                    log_error(f"Settings color option exceeded terminal height at y={current_y}: {option}")
                    break
                if global_idx == current_color_row and selected_section == 0:
                    current_y = type_text(stdscr, current_y, f"█ {option}", color_pair | curses.A_REVERSE, x_offset=x_offset)
                else:
                    current_y = type_text(stdscr, current_y, f"  {option}", color_pair, x_offset=x_offset)
            current_y += 1
            current_y = type_text(stdscr, current_y, "ANIMATION:", color_pair)
            for idx, option in enumerate(visible_anim_items):
                global_idx = idx + anim_scroll_offset
                if current_y >= max_y - 1:
                    log_error(f"Settings animation option exceeded terminal height at y={current_y}: {option}")
                    break
                if global_idx == current_anim_row and selected_section == 1:
                    current_y = type_text(stdscr, current_y, f"█ {option}", color_pair | curses.A_REVERSE, x_offset=x_offset)
                else:
                    current_y = type_text(stdscr, current_y, f"  {option}", color_pair, x_offset=x_offset)
            type_text(stdscr, max_y - 1, "USE ARROW KEYS TO NAVIGATE, ENTER TO SELECT, ESC TO RETURN", color_pair)
            first_draw = False
        else:
            current_y = start_y
            stdscr.addstr(current_y, (max_x - len("=== MU/TH/UR INTERFACE ===")) // 2, "=== MU/TH/UR INTERFACE ===", color_pair | curses.A_BOLD)
            current_y += 1
            stdscr.addstr(current_y, (max_x - len("== SETTINGS ==")) // 2, "== SETTINGS ==", color_pair)
            current_y += 1
            stdscr.addstr(current_y, (max_x - len("TEXT COLOR:")) // 2, "TEXT COLOR:", color_pair)
            current_y += 1
            for idx, option in enumerate(visible_color_items):
                global_idx = idx + color_scroll_offset
                if current_y >= max_y - 1:
                    log_error(f"Settings color option exceeded terminal height at y={current_y}: {option}")
                    break
                stdscr.addstr(current_y, x_offset, f"█ {option}" if global_idx == current_color_row and selected_section == 0 else f"  {option}", 
                             color_pair | (curses.A_REVERSE if global_idx == current_color_row and selected_section == 0 else 0))
                current_y += 1
            current_y += 1
            stdscr.addstr(current_y, (max_x - len("ANIMATION:")) // 2, "ANIMATION:", color_pair)
            current_y += 1
            for idx, option in enumerate(visible_anim_items):
                global_idx = idx + anim_scroll_offset
                if current_y >= max_y - 1:
                    log_error(f"Settings animation option exceeded terminal height at y={current_y}: {option}")
                    break
                stdscr.addstr(current_y, x_offset, f"█ {option}" if global_idx == current_anim_row and selected_section == 1 else f"  {option}", 
                             color_pair | (curses.A_REVERSE if global_idx == current_anim_row and selected_section == 1 else 0))
                current_y += 1
            stdscr.addstr(max_y - 1, (max_x - len("USE ARROW KEYS TO NAVIGATE, ENTER TO SELECT, ESC TO RETURN")) // 2, 
                         "USE ARROW KEYS TO NAVIGATE, ENTER TO SELECT, ESC TO RETURN", color_pair)
        stdscr.refresh()

        key = stdscr.getch()
        if key == curses.KEY_UP:
            if selected_section == 0 and current_color_row > 0:
                current_color_row -= 1
            elif selected_section == 1 and current_anim_row > 0:
                current_anim_row -= 1
        elif key == curses.KEY_DOWN:
            if selected_section == 0 and current_color_row < max_color_row:
                current_color_row += 1
            elif selected_section == 1 and current_anim_row < max_anim_row:
                current_anim_row += 1
        elif key == curses.KEY_LEFT or key == curses.KEY_RIGHT:
            selected_section = 1 - selected_section
            current_y = start_y + 3
            if selected_section == 0:
                for idx, option in enumerate(visible_color_items):
                    global_idx = idx + color_scroll_offset
                    if current_y >= max_y - 1:
                        log_error(f"Settings color option exceeded terminal height at y={current_y}: {option}")
                        break
                    stdscr.addstr(current_y, x_offset, f"█ {option}" if global_idx == current_color_row else f"  {option}", 
                                 color_pair | (curses.A_REVERSE if global_idx == current_color_row and selected_section == 0 else 0))
                    current_y += 1
            else:
                current_y += len(visible_color_items) + 1
                for idx, option in enumerate(visible_anim_items):
                    global_idx = idx + anim_scroll_offset
                    if current_y >= max_y - 1:
                        log_error(f"Settings animation option exceeded terminal height at y={current_y}: {option}")
                        break
                    stdscr.addstr(current_y, x_offset, f"█ {option}" if global_idx == current_anim_row else f"  {option}", 
                                 color_pair | (curses.A_REVERSE if global_idx == current_anim_row and selected_section == 1 else 0))
                    current_y += 1
        elif key == 10:
            if selected_section == 0:
                settings['text_color'] = color_options[current_color_row].lower()
                color_pair = get_color_pair()
                first_draw = True
            else:
                settings['animation_enabled'] = current_anim_row == 0
            save_settings(settings)
        elif key == 27:
            return color_pair

def menu(stdscr):
    """Display and handle the interactive menu with scrolling support."""
    curses.curs_set(0)
    curses.init_pair(1, curses.COLOR_GREEN, curses.COLOR_BLACK)
    curses.init_pair(2, curses.COLOR_WHITE, curses.COLOR_BLACK)
    curses.init_pair(3, curses.COLOR_CYAN, curses.COLOR_BLACK)
    curses.init_pair(4, curses.COLOR_RED, curses.COLOR_BLACK)
    curses.init_pair(5, curses.COLOR_YELLOW, curses.COLOR_BLACK)
    curses.init_pair(6, curses.COLOR_MAGENTA, curses.COLOR_BLACK)
    menu_items = ["COMMANDS", "SEARCH", "SETTINGS", "SHUTDOWN"]
    current_row = 0
    max_row = len(menu_items) - 1
    first_draw = True
    color_pair = get_color_pair()
    max_y, max_x = stdscr.getmaxyx()
    scroll_offset = 0

    max_item_width = max(len(item) for item in menu_items) + 2
    x_offset = (max_x - max_item_width) // 2
    if x_offset < 0:
        x_offset = 0
    padded_items = [item.ljust(max_item_width - 2) for item in menu_items]

    max_visible_items = max_y - 4  # Header, subtitle, spacing, instruction
    if max_visible_items < 1:
        max_visible_items = 1

    while True:
        stdscr.clear()
        if current_row < scroll_offset:
            scroll_offset = current_row
        elif current_row >= scroll_offset + max_visible_items:
            scroll_offset = current_row - max_visible_items + 1

        visible_items = padded_items[scroll_offset:scroll_offset + max_visible_items]
        total_lines = len(visible_items) + 4
        start_y = (max_y - total_lines) // 2
        if start_y < 0:
            start_y = 0

        if first_draw:
            current_y = start_y
            current_y = type_text(stdscr, current_y, "=== MU/TH/UR INTERFACE ===", color_pair | curses.A_BOLD)
            current_y = type_text(stdscr, current_y, "== WEYLAND-YUTANI CORP ==", color_pair)
            current_y += 1
            for idx, item in enumerate(visible_items):
                global_idx = idx + scroll_offset
                if current_y >= max_y - 1:
                    log_error(f"Menu item exceeded terminal height at y={current_y}: {item}")
                    break
                text = f"█ {item}" if global_idx == current_row else f"  {item}"
                current_y = type_text(stdscr, current_y, text, color_pair | (curses.A_REVERSE if global_idx == current_row else 0), x_offset=x_offset)
            type_text(stdscr, max_y - 1, "USE ARROW KEYS TO NAVIGATE, ENTER TO SELECT, ESC TO STAY", color_pair)
            first_draw = False
        else:
            current_y = start_y
            stdscr.addstr(current_y, (max_x - len("=== MU/TH/UR INTERFACE ===")) // 2, "=== MU/TH/UR INTERFACE ===", color_pair | curses.A_BOLD)
            current_y += 1
            stdscr.addstr(current_y, (max_x - len("== WEYLAND-YUTANI CORP ==")) // 2, "== WEYLAND-YUTANI CORP ==", color_pair)
            current_y += 1
            for idx, item in enumerate(visible_items):
                global_idx = idx + scroll_offset
                if current_y >= max_y - 1:
                    log_error(f"Menu item exceeded terminal height at y={current_y}: {item}")
                    break
                stdscr.addstr(current_y, x_offset, f"█ {item}" if global_idx == current_row else f"  {item}", 
                             color_pair | (curses.A_REVERSE if global_idx == current_row else 0))
                current_y += 1
            stdscr.addstr(max_y - 1, (max_x - len("USE ARROW KEYS TO NAVIGATE, ENTER TO SELECT, ESC TO STAY")) // 2, 
                         "USE ARROW KEYS TO NAVIGATE, ENTER TO SELECT, ESC TO STAY", color_pair)
        stdscr.refresh()

        key = stdscr.getch()
        if key == curses.KEY_UP and current_row > 0:
            current_row -= 1
        elif key == curses.KEY_DOWN and current_row < max_row:
            current_row += 1
        elif key == 10:
            if current_row == 0:
                run_commands(stdscr)
                first_draw = False
            elif current_row == 1:
                run_search(stdscr)
                first_draw = False
            elif current_row == 2:
                color_pair = run_settings(stdscr, color_pair)
                first_draw = False
            elif current_row == 3:
                shutdown_sequence(stdscr)
                return
        elif key == 27:
            pass

def main():
    """Main function to check for curses and run the appropriate interface."""
    update_commands()
    if curses is None:
        print("ERROR: 'CURSES' LIBRARY NOT AVAILABLE. FALLING BACK TO COMMAND-LINE MODE.")
        parser = argparse.ArgumentParser(
            description="CONVERT LINE ENDINGS OF A TEXT FILE FOR CROSS-PLATFORM COMPATIBILITY."
        )
        parser.add_argument('input_file', help="PATH TO THE INPUT FILE")
        parser.add_argument('output_file', help="PATH TO THE OUTPUT FILE")
        parser.add_argument(
            '-f', '--format',
            choices=['unix', 'windows', 'mac'],
            required=True,
            help="TARGET LINE ENDING FORMAT: 'UNIX' (LF), 'WINDOWS' (CRLF), OR 'MAC' (CR)"
        )
        args = parser.parse_args()
        input_file = args.input_file
        if not os.path.isabs(input_file):
            cyberdeck_input = os.path.join(CYBERDECK_DIR, input_file)
            if os.path.exists(cyberdeck_input):
                input_file = cyberdeck_input
        if not os.path.exists(input_file):
            print(f"ERROR: INPUT FILE '{input_file}' DOES NOT EXIST.")
            sys.exit(1)
        output_file = args.output_file
        if not os.path.isabs(output_file):
            output_file = os.path.join(CYBERDECK_DIR, output_file)
        result = convert_line_endings(input_file, output_file, args.format)
        print(result)
    else:
        curses.wrapper(boot_sequence)
        curses.wrapper(menu)

if __name__ == '__main__':
    main()
