#!/usr/bin/python3
import argparse
import sys
import os
import time
import json
import requests
from collections import defaultdict
try:
    import curses
except ImportError:
    curses = None
try:
    import pyperclip
except ImportError:
    pyperclip = None

# Default settings
default_settings = {
    'text_color': 'yellow',
    'animation_enabled': True
}

# Cyberdeck directory in user's home
CYBERDECK_DIR = os.path.join(os.path.expanduser("~"), ".cyberdeck")
SETTINGS_FILE = os.path.join(CYBERDECK_DIR, "settings.json")
COMMANDS_FILE = os.path.join(CYBERDECK_DIR, "commands.json")
ERROR_LOG = os.path.join(CYBERDECK_DIR, "error.log")

# Margin settings for borders
BORDER_MARGIN_X = 4  # Horizontal margin on each side
BORDER_MARGIN_Y = 2  # Vertical margin on top/bottom

def log_error(message):
    """Log errors to ~/.cyberdeck/error.log."""
    try:
        os.makedirs(CYBERDECK_DIR, exist_ok=True)
        with open(ERROR_LOG, 'a') as f:
            timestamp = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
            f.write(f"[{timestamp}] {message}\n")
    except Exception:
        pass

def load_settings():
    """Load settings from ~/.cyberdeck/settings.json or return defaults."""
    try:
        os.makedirs(CYBERDECK_DIR, exist_ok=True)
        with open(SETTINGS_FILE, 'r') as f:
            return json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        return default_settings.copy()

def save_settings(settings):
    """Save settings to ~/.cyberdeck/settings.json."""
    try:
        os.makedirs(CYBERDECK_DIR, exist_ok=True)
        with open(SETTINGS_FILE, 'w') as f:
            json.dump(settings, f, indent=4)
    except Exception as e:
        log_error(f"Failed to save settings: {str(e)}")

# Global settings
settings = load_settings()

def version_tuple(v):
    """Convert version string to tuple for comparison."""
    return tuple(map(int, v.split('.')))

def update_commands():
    """Fetch and update commands.json if remote version is higher."""
    url = "https://raw.githubusercontent.com/DotNetRussell/CyberDeck/refs/heads/main/commands.json"
    local_file = COMMANDS_FILE
    try:
        response = requests.get(url, timeout=5)
        response.raise_for_status()
        remote_data = response.json()
        remote_version = remote_data.get("Version", "0.0.0.0")
        local_version = "0.0.0.0"
        if os.path.exists(local_file):
            with open(local_file, 'r') as f:
                local_data = json.load(f)
                local_version = local_data.get("Version", "0.0.0.0")
        if version_tuple(remote_version) > version_tuple(local_version):
            with open(local_file, 'w') as f:
                json.dump(remote_data, f, indent=4)
    except Exception as e:
        log_error(f"Failed to update commands.json: {str(e)}")

def convert_line_endings(input_file, output_file, format_type):
    """Convert line endings of a file to the specified format."""
    try:
        if not os.path.isabs(input_file):
            cyberdeck_input = os.path.join(CYBERDECK_DIR, input_file)
            if os.path.exists(cyberdeck_input):
                input_file = cyberdeck_input
        if not os.path.exists(input_file):
            raise FileNotFoundError(f"Input file '{input_file}' not found.")
        
        with open(input_file, 'r', newline='') as infile:
            content = infile.read()
        
        if format_type.lower() == 'unix':
            new_line_ending = '\n'
        elif format_type.lower() == 'windows':
            new_line_ending = '\r\n'
        elif format_type.lower() == 'mac':
            new_line_ending = '\r'
        else:
            raise ValueError(f"UNSUPPORTED FORMAT: {format_type}. USE 'UNIX', 'WINDOWS', OR 'MAC'.")

        lines = content.replace('\r\n', '\n').replace('\r', '\n').split('\n')
        
        if not os.path.isabs(output_file):
            output_file = os.path.join(CYBERDECK_DIR, output_file)
        os.makedirs(os.path.dirname(output_file) or '.', exist_ok=True)
        
        with open(output_file, 'w', newline=new_line_ending) as outfile:
            outfile.write(new_line_ending.join(lines))
        
        return f"SUCCESSFULLY CONVERTED {input_file} TO {format_type.upper()} LINE ENDINGS AND SAVED TO {output_file}"
    
    except FileNotFoundError as e:
        return f"ERROR: {str(e).upper()}"
    except PermissionError:
        return f"ERROR: PERMISSION DENIED WHEN ACCESSING FILES."
    except Exception as e:
        return f"ERROR: {str(e).upper()}"

def get_wrapped_line_count(text, max_width):
    """Compute the number of lines after wrapping the text."""
    safe_text = ''.join(c if 32 <= ord(c) <= 126 else '' for c in text)
    lines = []
    current_line = ""
    for word in safe_text.split():
        test_line = current_line + (" " if current_line else "") + word
        if len(test_line) <= max_width:
            current_line = test_line
        else:
            if current_line:
                lines.append(current_line)
            current_line = word
    if current_line:
        lines.append(current_line)
    return len(lines)

def type_text(stdscr, y, text, color_pair, delay=0.01, x_offset=None, center_vertically=False, animate=None):
    """Display text with wrapping, safe character handling, centered horizontally and optionally vertically."""
    if animate is None:
        do_animate = settings['animation_enabled']
    else:
        do_animate = animate
    safe_text = ''.join(c if 32 <= ord(c) <= 126 else '' for c in text)
    max_y, max_x = stdscr.getmaxyx()
    # Apply horizontal margins to effective width
    effective_max_x = max_x - (2 * BORDER_MARGIN_X)
    max_width = effective_max_x - 4  # Additional padding inside margins
    
    lines = []
    current_line = ""
    for word in safe_text.split():
        test_line = current_line + (" " if current_line else "") + word
        if len(test_line) <= max_width:
            current_line = test_line
        else:
            if current_line:
                lines.append(current_line)
            current_line = word
    if current_line:
        lines.append(current_line)
    
    if center_vertically:
        total_lines = len(lines)
        y = (max_y - total_lines) // 2
        if y < 0:
            y = 0
    
    current_y = y
    for line in lines:
        if current_y >= max_y:
            log_error(f"Text wrapping exceeded terminal height at y={current_y}: {line}")
            break
        # Apply horizontal centering with margins
        x = x_offset if x_offset is not None else (effective_max_x - len(line)) // 2 + BORDER_MARGIN_X
        if x < BORDER_MARGIN_X:
            x = BORDER_MARGIN_X
        if not do_animate:
            try:
                stdscr.addstr(current_y, x, line, color_pair)
            except Exception as e:
                log_error(f"Failed to display text (non-animated) at y={current_y}, x={x}: {str(e)}")
            current_y += 1
            continue
        
        try:
            for char in line:
                if current_y >= max_y:
                    log_error(f"Text wrapping exceeded terminal height at y={current_y}, x={x}: {line}")
                    break
                stdscr.addch(current_y, x, char, color_pair)
                stdscr.refresh()
                x += 1
                time.sleep(delay)
            current_y += 1
        except Exception as e:
            try:
                stdscr.addstr(current_y, x_offset if x_offset is not None else (effective_max_x - len(line)) // 2 + BORDER_MARGIN_X, line, color_pair)
                current_y += 1
            except Exception as e2:
                log_error(f"Failed to display text at y={current_y}, x={x_offset if x_offset is not None else (effective_max_x - len(line)) // 2 + BORDER_MARGIN_X}: {str(e)} / {str(e2)}")
                current_y += 1
    
    return current_y

def boot_sequence(stdscr):
    """Display a Nostromo-inspired boot sequence with vertical centering and margins."""
    stdscr.clear()
    max_y, _ = stdscr.getmaxyx()
    lines = [
        "WEYLAND-YUTANI CORP SYSTEM INITIALIZATION",
        "MEMORY CHECK: 16MB OK",
        "CPU: 8086 PROCESSOR DETECTED",
        "STORAGE: 512KB AVAILABLE",
        "INTERFACE: CRT TERMINAL v1.0",
        "BOOTING MU/TH/UR OS v2.1.7",
        "INITIALIZATION COMPLETE"
    ]
    color_pair = get_color_pair()
    # Vertical centering with top/bottom margins
    effective_max_y = max_y - (2 * BORDER_MARGIN_Y)
    start_y = BORDER_MARGIN_Y + (effective_max_y - len(lines) - 1) // 2
    if start_y < BORDER_MARGIN_Y:
        start_y = BORDER_MARGIN_Y
    current_y = start_y
    for line in lines:
        if current_y >= max_y - BORDER_MARGIN_Y:
            log_error(f"Boot sequence exceeded terminal height at y={current_y}: {line}")
            break
        current_y = type_text(stdscr, current_y, line, color_pair | curses.A_BOLD)
    type_text(stdscr, max_y - BORDER_MARGIN_Y - 1, "PRESS ANY KEY TO CONTINUE", color_pair)
    stdscr.refresh()
    stdscr.getch()

def shutdown_sequence(stdscr):
    """Display a hacker-inspired shutdown animation with vertical centering and margins."""
    stdscr.clear()
    max_y, _ = stdscr.getmaxyx()
    lines = [
        "SYSTEM TERMINATION INITIATED",
        "DEACTIVATING CORE MODULES...",
        "1010101010101010101010101010",
        "FLUSHING MEMORY BUFFERS...",
        "0101010101010101010101010101",
        "DISCONNECTING NETWORK LINKS",
        "WEYLAND-YUTANI CORP: OFFLINE",
        "SHUTDOWN COMPLETE"
    ]
    color_pair = get_color_pair()
    # Vertical centering with margins
    effective_max_y = max_y - (2 * BORDER_MARGIN_Y)
    start_y = BORDER_MARGIN_Y + (effective_max_y - len(lines) - 1) // 2
    if start_y < BORDER_MARGIN_Y:
        start_y = BORDER_MARGIN_Y
    current_y = start_y
    for line in lines:
        if current_y >= max_y - BORDER_MARGIN_Y:
            log_error(f"Shutdown sequence exceeded terminal height at y={current_y}: {line}")
            break
        current_y = type_text(stdscr, current_y, line, color_pair | curses.A_BOLD)
        time.sleep(0.2)
    type_text(stdscr, max_y - BORDER_MARGIN_Y - 1, "SHUTDOWN COMPLETE", color_pair)
    stdscr.refresh()
    time.sleep(1)

def get_color_pair():
    """Return the color pair based on settings."""
    color_map = {
        'green': curses.color_pair(1),
        'white': curses.color_pair(2),
        'cyan': curses.color_pair(3),
        'red': curses.color_pair(4),
        'yellow': curses.color_pair(5),
        'purple': curses.color_pair(6) | curses.A_BOLD,
        'pink': curses.color_pair(6),
        'toxic green': curses.color_pair(1) | curses.A_BOLD
    }
    return color_map.get(settings['text_color'], curses.color_pair(1))

def list_menu(stdscr, title, items, get_text):
    """General navigable list menu with scrolling support and margins."""
    current_row = 0
    max_row = len(items) - 1
    max_y, max_x = stdscr.getmaxyx()
    scroll_offset = 0
    
    # Apply horizontal margins to effective width
    effective_max_x = max_x - (2 * BORDER_MARGIN_X)
    max_item_width = max(len(get_text(item)) + 2 for item in items)
    if max_item_width > effective_max_x:
        max_item_width = effective_max_x
    x_offset = BORDER_MARGIN_X + (effective_max_x - max_item_width) // 2
    if x_offset < BORDER_MARGIN_X:
        x_offset = BORDER_MARGIN_X
    
    # Calculate max visible items (reserve lines for header, title, instruction + margins)
    effective_max_y = max_y - (2 * BORDER_MARGIN_Y)
    max_visible_items = effective_max_y - 4  # Header, title, spacing, instruction
    if max_visible_items < 1:
        max_visible_items = 1
    
    max_width = effective_max_x - 4
    
    while True:
        # Precompute total content lines for accurate centering
        header_text = "=== MU/TH/UR INTERFACE ==="
        title_text = f"== {title.upper()} =="
        item_texts = []
        for idx in range(scroll_offset, min(scroll_offset + max_visible_items, len(items))):
            text = "  " + get_text(items[idx])
            item_texts.append(text)
        
        header_lines = get_wrapped_line_count(header_text, max_width)
        title_lines = get_wrapped_line_count(title_text, max_width)
        item_line_counts = [get_wrapped_line_count(text, max_width) for text in item_texts]
        total_content_lines = header_lines + title_lines + 1 + sum(item_line_counts)  # +1 for spacing after title
        
        start_y = BORDER_MARGIN_Y + (effective_max_y - total_content_lines) // 2
        if start_y < BORDER_MARGIN_Y:
            start_y = BORDER_MARGIN_Y
        
        stdscr.clear()
        color_pair = get_color_pair()
        
        # Adjust scroll_offset to keep current_row visible
        if current_row < scroll_offset:
            scroll_offset = current_row
        elif current_row >= scroll_offset + max_visible_items:
            scroll_offset = current_row - max_visible_items + 1
        
        current_y = start_y
        current_y = type_text(stdscr, current_y, header_text, color_pair | curses.A_BOLD, x_offset=None, animate=False)
        current_y = type_text(stdscr, current_y, title_text, color_pair, x_offset=None, animate=False)
        current_y += 1
        for idx in range(max_visible_items):
            if scroll_offset + idx >= len(items):
                break
            global_idx = scroll_offset + idx
            if current_y >= max_y - BORDER_MARGIN_Y - 1:
                log_error(f"Menu item exceeded terminal height at y={current_y}")
                break
            attr = color_pair | (curses.A_REVERSE if global_idx == current_row else 0)
            text = "  " + get_text(items[global_idx])
            current_y = type_text(stdscr, current_y, text, attr, x_offset=x_offset, animate=False)
        type_text(stdscr, max_y - BORDER_MARGIN_Y - 1, "USE ARROW KEYS TO NAVIGATE, ENTER TO SELECT, ESC TO BACK", color_pair, x_offset=None, animate=False)
        stdscr.refresh()
        key = stdscr.getch()
        if key == curses.KEY_UP and current_row > 0:
            current_row -= 1
        elif key == curses.KEY_DOWN and current_row < max_row:
            current_row += 1
        elif key == 10:
            return items[current_row]
        elif key == 27:
            return None

def show_details(stdscr, cmd):
    """Show command details screen with copy to clipboard option, updated format."""
    color_pair = get_color_pair()
    max_y, max_x = stdscr.getmaxyx()
    # Build lines with new format: Name:\nDescription (wrapped by type_text)\n\nCOMMAND: ...
    lines = [
        ("=== MU/TH/UR INTERFACE ===", curses.A_BOLD),
        (f"{cmd['Name']}:", curses.A_BOLD),
        ("", 0),
        ("", 0),
        (cmd['Description'], 0),
        ("", 0),
        ("", 0),
        (f"OS: {cmd['OS']}", 0),
        ("", 0),
        ("", 0),
        (f"COMMAND: {cmd['Command']}", curses.A_BOLD)
    ]
    # Vertical centering with margins
    effective_max_y = max_y - (2 * BORDER_MARGIN_Y)
    effective_max_x = max_x - (2 * BORDER_MARGIN_X)
    max_width = effective_max_x - 4
    
    while True:
        # Precompute total content lines
        total_content_lines = sum(get_wrapped_line_count(text, max_width) for text, _ in lines)
        start_y = BORDER_MARGIN_Y + (effective_max_y - total_content_lines) // 2
        if start_y < BORDER_MARGIN_Y:
            start_y = BORDER_MARGIN_Y
        
        stdscr.clear()
        current_y = start_y
        for text, bold in lines:
            if current_y >= max_y - BORDER_MARGIN_Y - 1:
                log_error(f"Details screen exceeded terminal height at y={current_y}: {text}")
                break
            attr = color_pair | (curses.A_BOLD if bold else 0)
            current_y = type_text(stdscr, current_y, text, attr, animate=False)
        type_text(stdscr, max_y - BORDER_MARGIN_Y - 1, "PRESS C TO COPY, ANY OTHER KEY TO RETURN.", color_pair, animate=False)
        stdscr.refresh()
        key = stdscr.getch()
        if key == ord('c') or key == ord('C'):
            if pyperclip:
                try:
                    pyperclip.copy(cmd['Command'])
                    stdscr.clear()
                    message_lines = [
                        ("=== MU/TH/UR INTERFACE ===", curses.A_BOLD),
                        ("COMMAND COPIED TO CLIPBOARD.", 0)
                    ]
                    total_message_lines = sum(get_wrapped_line_count(text, max_width) for text, _ in message_lines)
                    start_y = BORDER_MARGIN_Y + (effective_max_y - total_message_lines) // 2
                    if start_y < BORDER_MARGIN_Y:
                        start_y = BORDER_MARGIN_Y
                    current_y = start_y
                    for text, bold in message_lines:
                        attr = color_pair | (curses.A_BOLD if bold else 0)
                        current_y = type_text(stdscr, current_y, text, attr, animate=False)
                    type_text(stdscr, max_y - BORDER_MARGIN_Y - 1, "PRESS ANY KEY TO RETURN.", color_pair, animate=False)
                    stdscr.refresh()
                    stdscr.getch()
                except Exception as e:
                    stdscr.clear()
                    message_lines = [
                        ("=== MU/TH/UR INTERFACE ===", curses.A_BOLD),
                        (f"ERROR: FAILED TO COPY: {str(e).upper()}", 0)
                    ]
                    total_message_lines = sum(get_wrapped_line_count(text, max_width) for text, _ in message_lines)
                    start_y = BORDER_MARGIN_Y + (effective_max_y - total_message_lines) // 2
                    if start_y < BORDER_MARGIN_Y:
                        start_y = BORDER_MARGIN_Y
                    current_y = start_y
                    for text, bold in message_lines:
                        attr = color_pair | (curses.A_BOLD if bold else 0)
                        current_y = type_text(stdscr, current_y, text, attr, animate=False)
                    type_text(stdscr, max_y - BORDER_MARGIN_Y - 1, "PRESS ANY KEY TO RETURN.", color_pair, animate=False)
                    stdscr.refresh()
                    stdscr.getch()
            else:
                stdscr.clear()
                message_lines = [
                    ("=== MU/TH/UR INTERFACE ===", curses.A_BOLD),
                    ("ERROR: PYPERCLIP NOT INSTALLED.", 0)
                ]
                total_message_lines = sum(get_wrapped_line_count(text, max_width) for text, _ in message_lines)
                start_y = BORDER_MARGIN_Y + (effective_max_y - total_message_lines) // 2
                if start_y < BORDER_MARGIN_Y:
                    start_y = BORDER_MARGIN_Y
                current_y = start_y
                for text, bold in message_lines:
                    attr = color_pair | (curses.A_BOLD if bold else 0)
                    current_y = type_text(stdscr, current_y, text, attr, animate=False)
                type_text(stdscr, max_y - BORDER_MARGIN_Y - 1, "PRESS ANY KEY TO RETURN.", color_pair, animate=False)
                stdscr.refresh()
                stdscr.getch()
        else:
            break

def run_commands(stdscr):
    """Handle the Commands menu with categories and commands."""
    color_pair = get_color_pair()
    max_y, max_x = stdscr.getmaxyx()
    if not os.path.exists(COMMANDS_FILE):
        stdscr.clear()
        message_lines = [
            ("=== MU/TH/UR INTERFACE ===", curses.A_BOLD),
            ("NO COMMANDS AVAILABLE. PRESS ANY KEY TO RETURN.", 0)
        ]
        effective_max_y = max_y - (2 * BORDER_MARGIN_Y)
        effective_max_x = max_x - (2 * BORDER_MARGIN_X)
        max_width = effective_max_x - 4
        total_message_lines = sum(get_wrapped_line_count(text, max_width) for text, _ in message_lines)
        start_y = BORDER_MARGIN_Y + (effective_max_y - total_message_lines) // 2
        if start_y < BORDER_MARGIN_Y:
            start_y = BORDER_MARGIN_Y
        current_y = start_y
        for text, bold in message_lines:
            attr = color_pair | (curses.A_BOLD if bold else 0)
            current_y = type_text(stdscr, current_y, text, attr, animate=False)
        type_text(stdscr, max_y - BORDER_MARGIN_Y - 1, "PRESS ANY KEY TO RETURN.", color_pair, animate=False)
        stdscr.refresh()
        stdscr.getch()
        return

    with open(COMMANDS_FILE, 'r') as f:
        data = json.load(f)

    categories = {cat['id']: cat['Name'] for cat in data['Categories']}
    commands = data['commands']
    groups = defaultdict(list)
    for cmd in commands:
        groups[cmd['Category']].append(cmd)

    category_ids = sorted(groups.keys(), key=lambda cid: categories[cid].lower())

    while True:
        selected_cat = list_menu(stdscr, "COMMANDS CATEGORIES", category_ids, lambda cid: categories[cid])
        if selected_cat is None:
            return
        category_commands = sorted(groups[selected_cat], key=lambda c: c['Name'])
        selected_cmd = list_menu(
            stdscr,
            categories[selected_cat],
            category_commands,
            lambda cmd: f"{cmd['Name']} ({cmd['OS']})",  # Include OS in display
        )
        if selected_cmd is None:
            continue
        show_details(stdscr, selected_cmd)

def run_search(stdscr):
    """Handle the Search menu with query and results."""
    color_pair = get_color_pair()
    max_y, max_x = stdscr.getmaxyx()
    stdscr.clear()
    prompt = "ENTER SEARCH QUERY: "
    header_text = "=== MU/TH/UR INTERFACE ==="
    effective_max_y = max_y - (2 * BORDER_MARGIN_Y)
    effective_max_x = max_x - (2 * BORDER_MARGIN_X)
    start_y = BORDER_MARGIN_Y + (effective_max_y - 1) // 2
    if start_y < BORDER_MARGIN_Y:
        start_y = BORDER_MARGIN_Y
    type_text(stdscr, start_y, header_text, color_pair | curses.A_BOLD, animate=False)
    type_text(stdscr, max_y - BORDER_MARGIN_Y - 1, prompt + "__________", color_pair, animate=False)
    # Adjust move position with margins
    effective_prompt_x = BORDER_MARGIN_X + (effective_max_x - len(prompt + "__________")) // 2 + len(prompt)
    stdscr.move(max_y - BORDER_MARGIN_Y - 1, effective_prompt_x)
    stdscr.refresh()
    curses.echo()
    try:
        query = stdscr.getstr().decode('utf-8').strip().lower()
    except Exception as e:
        log_error(f"Failed to get search query: {str(e)}")
        query = ""
    curses.noecho()
    if not query:
        stdscr.clear()
        message_lines = [
            ("=== MU/TH/UR INTERFACE ===", curses.A_BOLD),
            ("NO QUERY ENTERED. PRESS ANY KEY TO RETURN.", 0)
        ]
        max_width = effective_max_x - 4
        total_message_lines = sum(get_wrapped_line_count(text, max_width) for text, _ in message_lines)
        start_y = BORDER_MARGIN_Y + (effective_max_y - total_message_lines) // 2
        if start_y < BORDER_MARGIN_Y:
            start_y = BORDER_MARGIN_Y
        current_y = start_y
        for text, bold in message_lines:
            attr = color_pair | (curses.A_BOLD if bold else 0)
            current_y = type_text(stdscr, current_y, text, attr, animate=False)
        type_text(stdscr, max_y - BORDER_MARGIN_Y - 1, "PRESS ANY KEY TO RETURN.", color_pair, animate=False)
        stdscr.refresh()
        stdscr.getch()
        return

    if not os.path.exists(COMMANDS_FILE):
        stdscr.clear()
        message_lines = [
            ("=== MU/TH/UR INTERFACE ===", curses.A_BOLD),
            ("NO COMMANDS AVAILABLE FOR SEARCH. PRESS ANY KEY TO RETURN.", 0)
        ]
        max_width = effective_max_x - 4
        total_message_lines = sum(get_wrapped_line_count(text, max_width) for text, _ in message_lines)
        start_y = BORDER_MARGIN_Y + (effective_max_y - total_message_lines) // 2
        if start_y < BORDER_MARGIN_Y:
            start_y = BORDER_MARGIN_Y
        current_y = start_y
        for text, bold in message_lines:
            attr = color_pair | (curses.A_BOLD if bold else 0)
            current_y = type_text(stdscr, current_y, text, attr, animate=False)
        type_text(stdscr, max_y - BORDER_MARGIN_Y - 1, "PRESS ANY KEY TO RETURN.", color_pair, animate=False)
        stdscr.refresh()
        stdscr.getch()
        return

    with open(COMMANDS_FILE, 'r') as f:
        data = json.load(f)

    commands = data['commands']
    words = query.split()
    filtered = []
    for cmd in commands:
        text = (cmd['Name'] + " " + cmd['Description'] + " " + cmd['Command'] + " " + cmd['OS']).lower()
        if all(word in text for word in words):
            filtered.append(cmd)
    if not filtered:
        stdscr.clear()
        message_lines = [
            ("=== MU/TH/UR INTERFACE ===", curses.A_BOLD),
            ("NO RESULTS FOUND. PRESS ANY KEY TO RETURN.", 0)
        ]
        max_width = effective_max_x - 4
        total_message_lines = sum(get_wrapped_line_count(text, max_width) for text, _ in message_lines)
        start_y = BORDER_MARGIN_Y + (effective_max_y - total_message_lines) // 2
        if start_y < BORDER_MARGIN_Y:
            start_y = BORDER_MARGIN_Y
        current_y = start_y
        for text, bold in message_lines:
            attr = color_pair | (curses.A_BOLD if bold else 0)
            current_y = type_text(stdscr, current_y, text, attr, animate=False)
        type_text(stdscr, max_y - BORDER_MARGIN_Y - 1, "PRESS ANY KEY TO RETURN.", color_pair, animate=False)
        stdscr.refresh()
        stdscr.getch()
        return

    sorted_filtered = sorted(filtered, key=lambda c: c['Name'])
    selected_cmd = list_menu(
        stdscr,
        "SEARCH RESULTS",
        sorted_filtered,
        lambda cmd: f"{cmd['Name']} ({cmd['OS']})",  # Include OS in display
    )
    if selected_cmd is not None:
        show_details(stdscr, selected_cmd)

def run_settings(stdscr, color_pair):
    """Handle the Settings menu with scrolling support and margins."""
    global settings
    max_y, max_x = stdscr.getmaxyx()
    color_options = sorted(["GREEN", "WHITE", "CYAN", "RED", "YELLOW", "PURPLE", "PINK", "TOXIC GREEN"])
    animation_options = sorted(["DISABLED", "ENABLED"])
    current_color_row = color_options.index(settings['text_color'].upper())
    current_anim_row = animation_options.index("ENABLED" if settings['animation_enabled'] else "DISABLED")
    selected_section = 0
    max_color_row = len(color_options) - 1
    max_anim_row = len(animation_options) - 1
    color_scroll_offset = 0
    anim_scroll_offset = 0

    # Apply margins
    effective_max_x = max_x - (2 * BORDER_MARGIN_X)
    max_item_width = max(len(option) + 2 for option in color_options + animation_options)
    if max_item_width > effective_max_x:
        max_item_width = effective_max_x
    x_offset = BORDER_MARGIN_X + (effective_max_x - max_item_width) // 2
    if x_offset < BORDER_MARGIN_X:
        x_offset = BORDER_MARGIN_X

    effective_max_y = max_y - (2 * BORDER_MARGIN_Y)
    max_visible_items = (effective_max_y - 6) // 2  # Header, title, color label, animation label, instruction, spacing
    if max_visible_items < 1:
        max_visible_items = 1

    max_width = effective_max_x - 4

    while True:
        # Adjust scroll offsets
        if selected_section == 0:
            if current_color_row < color_scroll_offset:
                color_scroll_offset = current_color_row
            elif current_color_row >= color_scroll_offset + max_visible_items:
                color_scroll_offset = current_color_row - max_visible_items + 1
        else:
            if current_anim_row < anim_scroll_offset:
                anim_scroll_offset = current_anim_row
            elif current_anim_row >= anim_scroll_offset + max_visible_items:
                anim_scroll_offset = current_anim_row - max_visible_items + 1

        color_item_texts = ["  " + color_options[idx] for idx in range(color_scroll_offset, min(color_scroll_offset + max_visible_items, len(color_options)))]
        anim_item_texts = ["  " + animation_options[idx] for idx in range(anim_scroll_offset, min(anim_scroll_offset + max_visible_items, len(animation_options)))]

        # Precompute total content lines
        header_text = "=== MU/TH/UR INTERFACE ==="
        settings_text = "== SETTINGS =="
        color_label = "TEXT COLOR:"
        anim_label = "ANIMATION:"
        header_lines = get_wrapped_line_count(header_text, max_width)
        settings_lines = get_wrapped_line_count(settings_text, max_width)
        color_label_lines = get_wrapped_line_count(color_label, max_width)
        anim_label_lines = get_wrapped_line_count(anim_label, max_width)
        color_item_lines = sum(get_wrapped_line_count(text, max_width) for text in color_item_texts)
        anim_item_lines = sum(get_wrapped_line_count(text, max_width) for text in anim_item_texts)
        total_content_lines = header_lines + settings_lines + 1 + color_label_lines + color_item_lines + 1 + anim_label_lines + anim_item_lines

        start_y = BORDER_MARGIN_Y + (effective_max_y - total_content_lines) // 2
        if start_y < BORDER_MARGIN_Y:
            start_y = BORDER_MARGIN_Y

        stdscr.clear()
        current_y = start_y
        current_y = type_text(stdscr, current_y, header_text, color_pair | curses.A_BOLD, x_offset=None, animate=False)
        current_y = type_text(stdscr, current_y, settings_text, color_pair, x_offset=None, animate=False)
        current_y += 1
        current_y = type_text(stdscr, current_y, color_label, color_pair, x_offset=x_offset, animate=False)
        for idx in range(len(color_item_texts)):
            global_idx = color_scroll_offset + idx
            if current_y >= max_y - BORDER_MARGIN_Y - 1:
                log_error(f"Settings color option exceeded terminal height at y={current_y}")
                break
            attr = color_pair | (curses.A_REVERSE if global_idx == current_color_row and selected_section == 0 else 0)
            current_y = type_text(stdscr, current_y, color_item_texts[idx], attr, x_offset=x_offset, animate=False)
        current_y += 1
        current_y = type_text(stdscr, current_y, anim_label, color_pair, x_offset=x_offset, animate=False)
        for idx in range(len(anim_item_texts)):
            global_idx = anim_scroll_offset + idx
            if current_y >= max_y - BORDER_MARGIN_Y - 1:
                log_error(f"Settings animation option exceeded terminal height at y={current_y}")
                break
            attr = color_pair | (curses.A_REVERSE if global_idx == current_anim_row and selected_section == 1 else 0)
            current_y = type_text(stdscr, current_y, anim_item_texts[idx], attr, x_offset=x_offset, animate=False)
        type_text(stdscr, max_y - BORDER_MARGIN_Y - 1, "USE ARROW KEYS TO NAVIGATE, ENTER TO SELECT, ESC TO RETURN", color_pair, x_offset=None, animate=False)
        stdscr.refresh()

        key = stdscr.getch()
        if key == curses.KEY_UP:
            if selected_section == 0 and current_color_row > 0:
                current_color_row -= 1
            elif selected_section == 1 and current_anim_row > 0:
                current_anim_row -= 1
        elif key == curses.KEY_DOWN:
            if selected_section == 0 and current_color_row < max_color_row:
                current_color_row += 1
            elif selected_section == 1 and current_anim_row < max_anim_row:
                current_anim_row += 1
        elif key == curses.KEY_LEFT or key == curses.KEY_RIGHT:
            selected_section = 1 - selected_section
        elif key == 10:
            if selected_section == 0:
                settings['text_color'] = color_options[current_color_row].lower()
                color_pair = get_color_pair()
            else:
                settings['animation_enabled'] = animation_options[current_anim_row] == "ENABLED"
            save_settings(settings)
        elif key == 27:
            return color_pair

def menu(stdscr):
    """Display and handle the interactive menu with scrolling support and margins."""
    curses.curs_set(0)
    curses.init_pair(1, curses.COLOR_GREEN, curses.COLOR_BLACK)
    curses.init_pair(2, curses.COLOR_WHITE, curses.COLOR_BLACK)
    curses.init_pair(3, curses.COLOR_CYAN, curses.COLOR_BLACK)
    curses.init_pair(4, curses.COLOR_RED, curses.COLOR_BLACK)
    curses.init_pair(5, curses.COLOR_YELLOW, curses.COLOR_BLACK)
    curses.init_pair(6, curses.COLOR_MAGENTA, curses.COLOR_BLACK)
    menu_items = ["COMMANDS", "SEARCH", "SETTINGS", "SHUTDOWN"]
    current_row = 0
    max_row = len(menu_items) - 1
    color_pair = get_color_pair()
    max_y, max_x = stdscr.getmaxyx()
    scroll_offset = 0

    # Apply margins
    effective_max_x = max_x - (2 * BORDER_MARGIN_X)
    max_item_width = max(len(item) + 2 for item in menu_items)
    if max_item_width > effective_max_x:
        max_item_width = effective_max_x
    x_offset = BORDER_MARGIN_X + (effective_max_x - max_item_width) // 2
    if x_offset < BORDER_MARGIN_X:
        x_offset = BORDER_MARGIN_X

    effective_max_y = max_y - (2 * BORDER_MARGIN_Y)
    max_visible_items = effective_max_y - 4  # Header, subtitle, spacing, instruction
    if max_visible_items < 1:
        max_visible_items = 1

    max_width = effective_max_x - 4

    original_anim = settings['animation_enabled']

    while True:
        # Precompute total content lines
        header_text = "=== MU/TH/UR INTERFACE ==="
        subtitle_text = "== WEYLAND-YUTANI CORP =="
        item_texts = []
        for idx in range(scroll_offset, min(scroll_offset + max_visible_items, len(menu_items))):
            text = "  " + menu_items[idx]
            item_texts.append(text)
        
        header_lines = get_wrapped_line_count(header_text, max_width)
        subtitle_lines = get_wrapped_line_count(subtitle_text, max_width)
        item_line_counts = [get_wrapped_line_count(text, max_width) for text in item_texts]
        total_content_lines = header_lines + subtitle_lines + 1 + sum(item_line_counts)  # +1 for spacing after subtitle

        start_y = BORDER_MARGIN_Y + (effective_max_y - total_content_lines) // 2
        if start_y < BORDER_MARGIN_Y:
            start_y = BORDER_MARGIN_Y

        stdscr.clear()
        current_y = start_y
        current_y = type_text(stdscr, current_y, header_text, color_pair | curses.A_BOLD, x_offset=None, animate=False)
        current_y = type_text(stdscr, current_y, subtitle_text, color_pair, x_offset=None, animate=False)
        current_y += 1
        for idx in range(max_visible_items):
            if scroll_offset + idx >= len(menu_items):
                break
            global_idx = scroll_offset + idx
            if current_y >= max_y - BORDER_MARGIN_Y - 1:
                log_error(f"Menu item exceeded terminal height at y={current_y}")
                break
            attr = color_pair | (curses.A_REVERSE if global_idx == current_row else 0)
            text = "  " + menu_items[global_idx]
            current_y = type_text(stdscr, current_y, text, attr, x_offset=x_offset, animate=False)
        type_text(stdscr, max_y - BORDER_MARGIN_Y - 1, "USE ARROW KEYS TO NAVIGATE, ENTER TO SELECT, ESC TO STAY", color_pair, x_offset=None, animate=False)
        stdscr.refresh()

        key = stdscr.getch()
        if key == curses.KEY_UP and current_row > 0:
            current_row -= 1
        elif key == curses.KEY_DOWN and current_row < max_row:
            current_row += 1
        elif key == 10:
            if current_row == 0:
                run_commands(stdscr)
            elif current_row == 1:
                run_search(stdscr)
            elif current_row == 2:
                color_pair = run_settings(stdscr, color_pair)
            elif current_row == 3:
                settings['animation_enabled'] = original_anim
                shutdown_sequence(stdscr)
                return
        elif key == 27:
            pass

def main():
    """Main function to check for curses and run the appropriate interface."""
    update_commands()
    if curses is None:
        print("ERROR: 'CURSES' LIBRARY NOT AVAILABLE. FALLING BACK TO COMMAND-LINE MODE.")
        parser = argparse.ArgumentParser(
            description="CONVERT LINE ENDINGS OF A TEXT FILE FOR CROSS-PLATFORM COMPATIBILITY."
        )
        parser.add_argument('input_file', help="PATH TO THE INPUT FILE")
        parser.add_argument('output_file', help="PATH TO THE OUTPUT FILE")
        parser.add_argument(
            '-f', '--format',
            choices=['unix', 'windows', 'mac'],
            required=True,
            help="TARGET LINE ENDING FORMAT: 'UNIX' (LF), 'WINDOWS' (CRLF), OR 'MAC' (CR)"
        )
        args = parser.parse_args()
        input_file = args.input_file
        if not os.path.isabs(input_file):
            cyberdeck_input = os.path.join(CYBERDECK_DIR, input_file)
            if os.path.exists(cyberdeck_input):
                input_file = cyberdeck_input
        if not os.path.exists(input_file):
            print(f"ERROR: INPUT FILE '{input_file}' DOES NOT EXIST.")
            sys.exit(1)
        output_file = args.output_file
        if not os.path.isabs(output_file):
            output_file = os.path.join(CYBERDECK_DIR, output_file)
        result = convert_line_endings(input_file, output_file, args.format)
        print(result)
    else:
        curses.wrapper(boot_sequence)
        curses.wrapper(menu)

if __name__ == '__main__':
    main()